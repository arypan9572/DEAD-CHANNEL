<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DEAD CHANNEL</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{
  margin:0;
  padding:0;
  background:#04060b;
  overflow:hidden;
  font-family:monospace;
}
canvas{display:block}

/* HUD */
#hud{
  position:fixed;
  bottom:20px;
  left:50%;
  transform:translateX(-50%);
  color:#7fffd4;
  font-size:12px;
  letter-spacing:2px;
  opacity:0.9;
  pointer-events:none;
}
#status{
  position:fixed;
  top:20px;
  left:50%;
  transform:translateX(-50%);
  color:#fffc;
  opacity:0.8;
  font-size:14px;
}

/* TITLE */
#title{
  position:fixed;
  inset:0;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  color:#7fffd4;
  background:#04060b;
  z-index:1000;
}
#title h1{
  font-size:72px;
  margin:0;
  letter-spacing:8px;
}
#title p{
  opacity:0.7;
  margin-top:10px;
}
/* CRT / VHS Overlay Effects */
#crtOverlay, #noiseOverlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 2000;
}

#crtOverlay {
  background:
    linear-gradient(rgba(255,255,255,0.03) 1px, transparent 2px) repeat-y,
    radial-gradient(circle at center, rgba(255,255,255,0.03), transparent 70%);
  mix-blend-mode: overlay;
  transform: scale(1.02,1.02);
  border-radius: 4%;
}

#noiseOverlay {
  background: repeating-linear-gradient(
    0deg,
    rgba(255,255,255,0.02),
    rgba(255,255,255,0.02) 1px,
    transparent 2px
  );
  mix-blend-mode: lighten;
}

</style>
</head>
<body>

<div id="title">
  <h1 id="titleText">DEAD CHANNEL</h1>
  <p>PRESS ANY KEY</p>
</div>


<div id="status">STATUS: STABLE</div>
<div id="hud">SIGNAL ▓▓▓▓▓▓▓▓▓▓</div>
<canvas id="c"></canvas>
<div id="crtOverlay"></div>
<div id="noiseOverlay"></div>


<script>
/* ================= SETUP ================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const hud = document.getElementById("hud");
const status = document.getElementById("status");
const title = document.getElementById("title");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
addEventListener("resize", resize);

/* ==== FLOATING BACKGROUND IMAGE ==== */
const bgImg = new Image();
bgImg.src = "bg.png";

const bgObj = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  vx: (Math.random() * 0.6 + 0.2) * (Math.random() < 0.5 ? -1 : 1),
  vy: (Math.random() * 0.6 + 0.2) * (Math.random() < 0.5 ? -1 : 1),
  size: 40,
  angle: 0
};


/* ================= INPUT ================= */
const keys = {};
let started = false;


// ---------------------
// KEY PRESS HANDLING
// ---------------------
window.addEventListener("keydown", e => {
    // START GAME
    if(!started){
        started = true;
        title.style.display = "none";
        generateLevel();
        return;
    }

    // PAUSE TOGGLE
    if(e.key === "Escape") {
        paused = !paused;
        return;
    }

    keys[e.key.toLowerCase()] = true;
});

window.addEventListener("keyup", e => {
    keys[e.key.toLowerCase()] = false;
});


/* ================= STATE ================= */
let level = 1;
let score = 0;
let signal = 1;
let shake = 0;
let flash = 0;
let levelTime = 120; // seconds per level
let paused = false;
let pauseAlpha = 0;  // fade effect for pause screen

let stability = 100;           // 0–100
let stabilityTimer = 0;
let relayTimer = 0;

/* ================= PLAYER ================= */
const player = {
  x:0, y:0, r:10,
  vx:0, vy:0,
  speed:0.15,
  dash:0,
  angle:0
};


/* ================= ENTITIES ================= */
let relays=[], zones=[], anchors=[], boosts=[], enemies=[], exitNode=null;
let glitchSquares = [];

/* ===== HOME SCREEN ANIMATION ===== */
const homeAnchors = [];
for(let i=0;i<10;i++){ // floating background anchors
  homeAnchors.push({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height,
    r: 8 + Math.random()*8,
    pulse: Math.random()*6
  });
}

function drawHomeScreen(){

  /* ==== HOME SCREEN BG ==== */
bgObj.x += bgObj.vx * 0.3;
bgObj.y += bgObj.vy * 0.3;
bgObj.angle += 0.001;

ctx.fillStyle="#04060b";
ctx.fillRect(0,0,canvas.width,canvas.height);

ctx.save();
ctx.globalAlpha = 0.2;
ctx.translate(bgObj.x, bgObj.y);
ctx.rotate(bgObj.angle);
ctx.drawImage(bgImg, -bgObj.size/2, -bgObj.size/2, bgObj.size, bgObj.size);
ctx.restore();
ctx.globalAlpha = 1;


  // floating anchors
  homeAnchors.forEach(a=>{
    a.pulse += 1;
    ctx.strokeStyle="#7fffd4";
    ctx.shadowColor="#7fffd4";
    ctx.shadowBlur = 10 + Math.sin(a.pulse)*4;
    ctx.beginPath();
    ctx.arc(a.x,a.y,a.r+Math.sin(a.pulse)*2,0,6.28);
    ctx.stroke();
    ctx.shadowBlur=0;
  });

  // pulsing title
  const titleText = document.getElementById("titleText");
  const scale = 1 + Math.sin(performance.now()*0.0025)*0.05;
  titleText.style.transform = `scale(${scale})`;
}

/* ================= LEVEL GEN ================= */
function generateLevel(){
  relays=[]; zones=[]; anchors=[]; boosts=[]; enemies=[];
  signal = 1;
  stability = 100;
  flash = 0;
  levelTime = 120;


  player.x = canvas.width/2;
  player.y = canvas.height/2;
  player.vx = player.vy = 0;

  // ----- RELAY CLUSTERING (easy early, scattered later) -----
const relaySpread = Math.min(600, 120 + level * 80);
const relayCenterX = canvas.width / 2;
const relayCenterY = canvas.height / 2;

for(let i=0;i<level+2;i++){
  relays.push({
    x: relayCenterX + (Math.random()-0.5)*relaySpread,
    y: relayCenterY + (Math.random()-0.5)*relaySpread,
    r:14,
    active:false,
    decay:1,
    p:Math.random()*6
  });
}


  for(let i=0;i<level+1;i++){
    zones.push({
      x:Math.random()*canvas.width,
      y:Math.random()*canvas.height,
      r:50+Math.random()*30,
      drift:Math.random()*6
    });
  }

// ----- ANCHOR SCALING -----
const anchorCount = Math.max(1, 4 - Math.floor(level/3));
const anchorSpread = Math.min(500, 100 + level * 100);

for(let i=0;i<anchorCount;i++){
  anchors.push({
    x: canvas.width/2 + (Math.random()-0.5)*anchorSpread,
    y: canvas.height/2 + (Math.random()-0.5)*anchorSpread,
    r:18,
    pulse:Math.random()*6
  });
}


  for(let i=0;i<Math.floor(level/2);i++){
    boosts.push({
      x:Math.random()*canvas.width,
      y:Math.random()*canvas.height,
      r:8,
      type:Math.random()<0.5?"dash":"signal"
    });
  }

  for(let i=0;i<level;i++){
    enemies.push({
      x:Math.random()*canvas.width,
      y:Math.random()*canvas.height,
      r:8,
      vx:Math.random()*1.2-0.6,
      vy:Math.random()*1.2-0.6
    });
  }

  exitNode={
    x:Math.random()*canvas.width,
    y:Math.random()*canvas.height,
    r:18
  };
}
generateLevel();

/* ================= UPDATE ================= */
function update(dt){
  if (paused) return;
  if(!started) return;
  
  levelTime -= dt;
if(levelTime <= 0){
  flash = 1;
  generateLevel();
  return;
}


  let ax=0, ay=0;
  if(keys.w||keys.ArrowUp) ay--;
  if(keys.s||keys.ArrowDown) ay++;
  if(keys.a||keys.ArrowLeft) ax--;
  if(keys.d||keys.ArrowRight) ax++;

  if((keys[" "]||keys.Shift) && player.dash<=0){
    player.vx += ax*8;
    player.vy += ay*8;
    player.dash = 60;
  }

  player.vx += ax*player.speed;
  player.vy += ay*player.speed;
  player.vx *= 0.92;
  player.vy *= 0.92;

  player.x += player.vx;
  player.y += player.vy;
  player.dash--;

  /* ==== FLOATING BACKGROUND MOVEMENT ==== */
bgObj.x += bgObj.vx;
bgObj.y += bgObj.vy;

if (bgObj.x < bgObj.size || bgObj.x > canvas.width - bgObj.size) {
  bgObj.vx *= -1;
}
if (bgObj.y < bgObj.size || bgObj.y > canvas.height - bgObj.size) {
  bgObj.vy *= -1;
}

bgObj.angle += 0.002;

  /* Clamp to screen */
  player.x = Math.max(player.r, Math.min(canvas.width-player.r, player.x));
  player.y = Math.max(player.r, Math.min(canvas.height-player.r, player.y));

  /* Zones */
  let danger = 0;
  zones.forEach(z=>{
    z.drift += 0.01;
    if(Math.hypot(player.x-z.x,player.y-z.y) < z.r + Math.sin(z.drift)*10){
      signal -= 0.004;
      danger++;
      flash = 1;
    }
  });

  /* Anchors → stability */
  let nearAnchor = false;
  // ===== GLITCH SQUARE DRAW =====
glitchSquares.forEach(g=>{
  ctx.save();
  ctx.translate(g.x, g.y);

  const jitter = (Math.random()-0.5)*8;
  ctx.rotate(jitter*0.01);

  ctx.fillStyle = `rgba(255,0,0,${0.3 + Math.random()*0.4})`;
  ctx.shadowColor = "#ff0000";
  ctx.shadowBlur = 20;

  ctx.fillRect(
    -g.size/2 + jitter,
    -g.size/2,
    g.size,
    g.size
  );

  ctx.restore();
});

  anchors.forEach(a=>{
    const d = Math.hypot(player.x-a.x,player.y-a.y);
    if(d > a.r+player.r && d < 120) nearAnchor = true;
  });

  stabilityTimer += dt;
  if(stabilityTimer >= 0.2){
    stability += nearAnchor ? 1 : -1;
    stability = Math.max(0,Math.min(100,stability));
    // ===== GLITCH SQUARE SPAWN (instability buff) =====
if(stability < 40 && Math.random() < 0.02){
  glitchSquares.push({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height,
    size: 20 + Math.random()*20,
    life: 0,
    triggered: false
  });
}

    stabilityTimer = 0;
  }

  /* Relays */
  relays.forEach(r=>{
    const d = Math.hypot(player.x-r.x,player.y-r.y);
    if(d < r.r+player.r){
      r.active = true;
      r.decay = 1;
    }
  });

  relayTimer += dt;
  if(relayTimer >= 1){
    relays.forEach(r=>{
      if(r.active && Math.random()*100 > stability){
        r.active = false;
        r.decay = 0.2;
      }
    });
    relayTimer = 0;
  }

  /* Boosts */
  boosts.forEach((b,i)=>{
    if(Math.hypot(player.x-b.x,player.y-b.y)<b.r+player.r){
      if(b.type==="dash") player.dash=60;
      if(b.type==="signal") signal=Math.min(1,signal+0.3);
      boosts.splice(i,1);
    }
  });

  /* Enemies */
  enemies.forEach(e=>{
    e.x+=e.vx; e.y+=e.vy;
    if(Math.hypot(player.x-e.x,player.y-e.y)<e.r+player.r) signal-=0.05;
    if(e.x<0||e.x>canvas.width) e.vx*=-1;
    if(e.y<0||e.y>canvas.height) e.vy*=-1;
  });

  if(danger===0) signal+=0.0015;
  signal=Math.max(0,Math.min(1,signal));

  // ===== GLITCH SQUARE INTERACTION =====
glitchSquares.forEach((g,i)=>{
  g.life += dt;

  const d = Math.hypot(player.x-g.x, player.y-g.y);
  if(d < g.size && !g.triggered){
    g.triggered = true;

    // Restabilization reward chance
    if(stability > 60){
      const roll = Math.random();
      
      if(roll < 0.33){
        // RED EXIT PORTAL
        exitNode = {
          x: g.x,
          y: g.y,
          r: 20,
          red: true
        };
      } 
      else if(roll < 0.66){
        anchors.push({
          x:g.x,
          y:g.y,
          r:18,
          pulse:Math.random()*6
        });
      } 
      else {
        relays.push({
          x:g.x,
          y:g.y,
          r:14,
          active:false,
          decay:1,
          p:Math.random()*6
        });
      }
    }
  }

  // remove old glitch
  if(g.life > 6){
    glitchSquares.splice(i,1);
  }
});


  if(signal<=0){flash=1;generateLevel();}

  if(relays.every(r=>r.active) &&
     Math.hypot(player.x-exitNode.x,player.y-exitNode.y)<exitNode.r+player.r){
    score+=level*100;
    level++;
    generateLevel();
  }

  shake = danger*3 + (100-stability)*0.03;

  status.textContent =
    stability>70?"STATUS: STABLE":
    stability>40?"STATUS: UNSTABLE":"STATUS: CRITICAL";

  const minutes = Math.floor(levelTime / 60);
const seconds = Math.floor(levelTime % 60).toString().padStart(2,"0");

hud.textContent =
  `SIGNAL ${"▓".repeat(signal*10|0)}${"░".repeat(10-(signal*10|0))} | STAB ${stability}% | TIME ${minutes}:${seconds} | LVL ${level} | SCORE ${score}`;

}

/* ================= DRAW ================= */
function draw(){
  ctx.save();
  ctx.translate((Math.random()-.5)*shake,(Math.random()-.5)*shake);
  ctx.fillStyle="#04060b";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // handle pause fade
if(paused){
  pauseAlpha += 0.05;
  if(pauseAlpha>1) pauseAlpha=1;
}else{
  pauseAlpha -= 0.05;
  if(pauseAlpha<0) pauseAlpha=0;
}

  
  /* ==== FLOATING BACKGROUND IMAGE DRAW ==== */
if (bgImg.complete) {
  ctx.save();
  ctx.globalAlpha = 0.25;

  ctx.translate(bgObj.x, bgObj.y);
  ctx.rotate(bgObj.angle);
  ctx.drawImage(
    bgImg,
    -bgObj.size / 2,
    -bgObj.size / 2,
    bgObj.size,
    bgObj.size
  );

  ctx.restore();
  ctx.globalAlpha = 1;
}


  zones.forEach(z=>{
    ctx.strokeStyle="rgba(138,43,226,0.35)";
    ctx.shadowColor="#8a2be2";
    ctx.shadowBlur=20;
    ctx.beginPath();
    ctx.arc(z.x,z.y,z.r+Math.sin(z.drift)*10,0,6.28);
    ctx.stroke();
    ctx.shadowBlur=0;
  });

  relays.forEach(r=>{
    r.p+=0.05;
    ctx.fillStyle=r.active?"#5bb450":"#4E9FE5";
    ctx.shadowColor=ctx.fillStyle;
    ctx.shadowBlur=15*r.decay;
    ctx.beginPath();
    ctx.arc(r.x,r.y,r.r+Math.sin(r.p)*2,0,6.28);
    ctx.fill();
    ctx.shadowBlur=0;
  });

  anchors.forEach(a=>{
    a.pulse+=0.05;
ctx.strokeStyle = exitNode.red ? "#ff0000" : "#ffd700";
ctx.shadowColor = exitNode.red ? "#ff0000" : "#ffd700";
    ctx.shadowBlur=12;
    ctx.beginPath();
    ctx.arc(a.x,a.y,a.r+Math.sin(a.pulse)*3,0,6.28);
    ctx.stroke();
    ctx.shadowBlur=0;
  });

  boosts.forEach(b=>{
    ctx.fillStyle=b.type==="dash"?"#fffc00":"#00fffc";
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,6.28);
    ctx.fill();
  });

  enemies.forEach(e=>{
    ctx.fillStyle="#ff00ff";
    ctx.beginPath();
    ctx.arc(e.x,e.y,e.r,0,6.28);
    ctx.fill();
  });

  if(relays.every(r=>r.active)){
    ctx.strokeStyle="#ffd700";
    ctx.shadowColor="#ffd700";
    ctx.shadowBlur=20;
    ctx.beginPath();
    ctx.arc(exitNode.x,exitNode.y,exitNode.r,0,6.28);
    ctx.stroke();
    ctx.shadowBlur=0;
  }

 // Arrow player
let ax=0, ay=0;
if(keys.w||keys.ArrowUp) ay--;
if(keys.s||keys.ArrowDown) ay++;
if(keys.a||keys.ArrowLeft) ax--;
if(keys.d||keys.ArrowRight) ax++;

if(ax !== 0 || ay !== 0){
  let targetAngle = Math.atan2(ay, ax);
  let diff = targetAngle - player.angle;
  if(diff > Math.PI) diff -= Math.PI*2;
  if(diff < -Math.PI) diff += Math.PI*2;
  player.angle += diff * 0.15; // turn speed, adjust 0.15 to go faster/slower
}

ctx.save();
ctx.translate(player.x, player.y);
ctx.rotate(player.angle);
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.font = "30px monospace"; // arrow size
ctx.fillStyle = "#7fffd4";
ctx.fillText("➔", 0, 0);
ctx.restore();

  ctx.restore();

  ctx.fillStyle="rgba(255,255,255,0.03)";
  for(let y=0;y<canvas.height;y+=4) ctx.fillRect(0,y,canvas.width,1);

  const shift=Math.sin(performance.now()*0.004)*3;
  ctx.globalCompositeOperation="screen";
  ctx.drawImage(canvas,shift,0);
  ctx.drawImage(canvas,-shift,0);
  ctx.globalCompositeOperation="source-over";

  if(flash>0){
    ctx.fillStyle=`rgba(127,255,212,${flash*0.4})`;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    flash*=0.9;
  }
  /* ===== PAUSE OVERLAY ===== */
if (paused) {

  // Dark fade
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // "PAUSED" text (top-left)
  ctx.fillStyle = "#bbb";
  ctx.font = "22px monospace";
  ctx.textAlign = "left";
  ctx.fillText("PAUSED", 20, 32);

  
  // ❚❚ PAUSE LINES (crunchy, retro style)
ctx.save();
ctx.translate(canvas.width / 2, canvas.height / 2);
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.font = "120px monospace";
ctx.fillStyle = `rgba(187,187,187,${pauseAlpha})`;

for (let i = 0; i < 6; i++) {
  // tiny random offsets to make it look “handmade / crunchy”
  const offsetX = (Math.random() - 0.5) * 6;
  const offsetY = (Math.random() - 0.5) * 6;
  ctx.fillText("❚❚", offsetX, offsetY);
}
ctx.restore();


  // Static noise crunch
  for(let i=0;i<100;i++){
    ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.05})`;
    ctx.fillRect(
      Math.random()*canvas.width,
      Math.random()*canvas.height,
      2,
      2
    );
  }
}

}

/* ================= LOOP ================= */
let last=performance.now();
(function loop(t){
  const dt=(t-last)/1000;
  last=t;
  
  if(!started){
    drawHomeScreen();
  } else {
    update(dt);
    draw();
  }
  
  // CRT flicker overlay
  const crt = document.getElementById("crtOverlay");
  const noise = document.getElementById("noiseOverlay");
  crt.style.opacity = (0.1 + Math.random() * 0.05).toFixed(2);
  noise.style.opacity = (0.05 + Math.random() * 0.05).toFixed(2);
  
  requestAnimationFrame(loop);
})();

</script>
</body>
</html>
